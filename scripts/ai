#!/bin/bash

# ai - Universal AI Prompt Interpreter
#
# The unified entry point for AI Runner. Supports multiple AI tools and providers.
#
# Interactive mode:
#   ai                          # Auto-detect tool and provider
#   ai --aws --opus             # Claude Code via AWS Bedrock
#   ai --tool cc --ollama       # Claude Code via Ollama (local)
#
# Shebang mode:
#   ai prompt.md                # Execute markdown file
#   #!/usr/bin/env ai           # In markdown file
#
# Piped mode:
#   curl URL | ai               # Execute remote prompt
#   echo "prompt" | ai          # Execute piped content

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LIB_DIR="$SCRIPT_DIR/lib"

# Set branding for AI Runner
export AI_RUNNER_BRAND="AI Runner"

# Set PROVIDER_DIR and TOOL_DIR for loaders
export PROVIDER_DIR="$(cd "$SCRIPT_DIR/../providers" 2>/dev/null && pwd)"
export TOOL_DIR="$(cd "$SCRIPT_DIR/../tools" 2>/dev/null && pwd)"

# Source core utilities
source "$LIB_DIR/core-utils.sh"

# Source loaders
source "$LIB_DIR/provider-loader.sh"
source "$LIB_DIR/tool-loader.sh"

# --- Process isolation for nested/composable scripts ---
# When ai scripts call other ai scripts, children inherit the parent's
# exported env vars. Clear AI Runner-controlled vars so each invocation
# starts fresh, like a new bash shell.
unset ANTHROPIC_MODEL ANTHROPIC_SMALL_FAST_MODEL
unset ANTHROPIC_BASE_URL ANTHROPIC_AUTH_TOKEN
unset CLAUDE_CODE_USE_BEDROCK CLAUDE_CODE_USE_VERTEX CLAUDE_CODE_USE_FOUNDRY
unset AI_LIVE_OUTPUT AI_SESSION_ID CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS
unset CLAUDECODE

# Parse shebang flags into SHEBANG_* variables
# Called early to establish: CLI > shebang > defaults precedence
_parse_shebang_flags() {
    local line="$1"
    SHEBANG_PROVIDER=""
    SHEBANG_MODEL_TIER=""
    SHEBANG_LIVE=""
    SHEBANG_PERMISSION_SHORTCUT=""
    SHEBANG_PASSTHROUGH=()

    # Only parse shebangs referencing ai, airun, or claude-run
    [[ "$line" != *"ai"* && "$line" != *"claude-run"* ]] && return

    # Extract flags after the command name
    local flags=""
    if [[ "$line" =~ (airun|claude-run|ai)[[:space:]]+(.*) ]]; then
        flags="${BASH_REMATCH[2]}"
    else
        return
    fi

    local -a args
    read -ra args <<< "$flags"
    for arg in "${args[@]}"; do
        case "$arg" in
            --aws|--vertex|--apikey|--azure|--vercel|--pro)
                SHEBANG_PROVIDER="${arg#--}" ;;
            --ollama|--ol)
                SHEBANG_PROVIDER="ollama" ;;
            --lmstudio|--lm)
                SHEBANG_PROVIDER="lmstudio" ;;
            --opus|--high)
                SHEBANG_MODEL_TIER="high" ;;
            --sonnet|--mid)
                SHEBANG_MODEL_TIER="mid" ;;
            --haiku|--low)
                SHEBANG_MODEL_TIER="low" ;;
            --live)
                SHEBANG_LIVE=true ;;
            --skip)
                SHEBANG_PERMISSION_SHORTCUT="skip" ;;
            --bypass)
                SHEBANG_PERMISSION_SHORTCUT="bypass" ;;
            --cc)
                ;; # consumed by CLI parser, ignore in shebang re-parse
            *)
                # Pass through unrecognized flags (--chrome, --max-turns, etc.)
                SHEBANG_PASSTHROUGH+=("$arg") ;;
        esac
    done
}

# Capture stdin early if being piped to (not a TTY)
STDIN_CONTENT=""
if [[ ! -t 0 ]]; then
    STDIN_CONTENT=$(cat)
fi

# Parse arguments
TOOL_FLAG=""
PROVIDER_FLAG=""
MODEL_TIER=""
CUSTOM_MODEL=""
MD_FILE=""
CLAUDE_ARGS=()
NEEDS_VERBOSE=false
STDIN_POSITION="prepend"
SHOW_VERSION=false
SHOW_HELP=false
SET_DEFAULT=false
CLEAR_DEFAULT=false
TEAM_MODE=""
TEAMMATE_MODE=""
PERMISSION_SHORTCUT=""
EXPLICIT_PERMISSION_MODE=false
LIVE_OUTPUT=false

while [[ $# -gt 0 ]]; do
    case $1 in
        # Handle --output-format which requires --verbose for stream-json
        --output-format)
            CLAUDE_ARGS+=("$1" "$2")
            if [[ "$2" == "stream-json" ]]; then
                NEEDS_VERBOSE=true
            fi
            shift 2 ;;
        --output-format=*)
            CLAUDE_ARGS+=("$1")
            if [[ "$1" == "--output-format=stream-json" ]]; then
                NEEDS_VERBOSE=true
            fi
            shift ;;

        # Tool selection
        --tool)
            TOOL_FLAG="$2"
            shift 2 ;;
        --tool=*)
            TOOL_FLAG="${1#*=}"
            shift ;;
        --cc)
            TOOL_FLAG="cc"
            shift ;;

        # Provider selection (existing)
        --aws)     PROVIDER_FLAG="aws"; shift ;;
        --vertex)  PROVIDER_FLAG="vertex"; shift ;;
        --apikey)  PROVIDER_FLAG="apikey"; shift ;;
        --azure)   PROVIDER_FLAG="azure"; shift ;;
        --vercel)  PROVIDER_FLAG="vercel"; shift ;;
        --pro)     PROVIDER_FLAG="pro"; shift ;;

        # Provider selection (local)
        --ollama|--ol)     PROVIDER_FLAG="ollama"; shift ;;
        --lmstudio|--lm) PROVIDER_FLAG="lmstudio"; shift ;;

        # Agent Teams
        --team|--teams) TEAM_MODE="enabled"; shift ;;
        --teammate-mode)
            TEAMMATE_MODE="$2"
            CLAUDE_ARGS+=("$1" "$2")
            shift 2 ;;
        --teammate-mode=*)
            TEAMMATE_MODE="${1#*=}"
            CLAUDE_ARGS+=("$1")
            shift ;;

        # Model flags (Anthropic tier names)
        --opus)   MODEL_TIER="high"; shift ;;
        --sonnet) MODEL_TIER="mid"; shift ;;
        --haiku)  MODEL_TIER="low"; shift ;;

        # Model flags (universal tier aliases)
        --high) MODEL_TIER="high"; shift ;;
        --mid)  MODEL_TIER="mid"; shift ;;
        --low)  MODEL_TIER="low"; shift ;;

        # Custom model
        --model)
            CUSTOM_MODEL="$2"
            shift 2 ;;
        --model=*)
            CUSTOM_MODEL="${1#*=}"
            shift ;;

        # Permission shortcuts
        --skip)    PERMISSION_SHORTCUT="skip"; shift ;;
        --bypass)  PERMISSION_SHORTCUT="bypass"; shift ;;
        --live)    LIVE_OUTPUT=true; shift ;;

        # Permission flags (intercept to track explicit usage)
        --permission-mode)
            EXPLICIT_PERMISSION_MODE=true
            CLAUDE_ARGS+=("$1" "$2")
            shift 2 ;;
        --permission-mode=*)
            EXPLICIT_PERMISSION_MODE=true
            CLAUDE_ARGS+=("$1")
            shift ;;
        --dangerously-skip-permissions)
            EXPLICIT_PERMISSION_MODE=true
            CLAUDE_ARGS+=("$1")
            shift ;;

        # Detect markdown file (positional argument ending in .md)
        *.md)
            if [[ -f "$1" ]]; then
                MD_FILE="$1"
            else
                print_error "File not found: $1"
                exit 1
            fi
            shift ;;

        # Stdin position for piped input
        --stdin-position)
            STDIN_POSITION="$2"
            if [[ "$STDIN_POSITION" != "prepend" && "$STDIN_POSITION" != "append" ]]; then
                print_error "Invalid --stdin-position: $2 (must be 'prepend' or 'append')"
                exit 1
            fi
            shift 2 ;;

        # Version flag
        --version|-v)
            SHOW_VERSION=true
            shift ;;

        # Help flag
        --help|-h)
            SHOW_HELP=true
            shift ;;

        # Subcommands
        update)
            source "$LIB_DIR/update-checker.sh"
            run_update
            exit $? ;;

        # Default preference flags
        --set-default) SET_DEFAULT=true; shift ;;
        --clear-default) CLEAR_DEFAULT=true; shift ;;

        # Everything else passes through to the tool
        *)
            CLAUDE_ARGS+=("$1")
            shift ;;
    esac
done

# --- Early shebang flag parsing ---
# Extract shebang from file or stdin and parse flags
# Precedence: CLI > shebang > saved defaults
_SHEBANG_LINE=""
if [[ -n "$MD_FILE" && -f "$MD_FILE" ]]; then
    _SHEBANG_LINE=$(head -1 "$MD_FILE")
elif [[ -n "$STDIN_CONTENT" ]]; then
    _SHEBANG_LINE="${STDIN_CONTENT%%$'\n'*}"
fi

if [[ "$_SHEBANG_LINE" == "#!"* ]]; then
    _parse_shebang_flags "$_SHEBANG_LINE"

    # Apply shebang flags where CLI didn't set them
    [[ -z "$PROVIDER_FLAG" && -n "$SHEBANG_PROVIDER" ]] && PROVIDER_FLAG="$SHEBANG_PROVIDER"
    [[ -z "$MODEL_TIER" && -z "$CUSTOM_MODEL" && -n "$SHEBANG_MODEL_TIER" ]] && MODEL_TIER="$SHEBANG_MODEL_TIER"
    [[ "$LIVE_OUTPUT" != true && "$SHEBANG_LIVE" == true ]] && LIVE_OUTPUT=true
    [[ -z "$PERMISSION_SHORTCUT" && -n "$SHEBANG_PERMISSION_SHORTCUT" ]] && PERMISSION_SHORTCUT="$SHEBANG_PERMISSION_SHORTCUT"
    # Pass through unrecognized flags (--chrome, --max-turns, etc.)
    [[ ${#SHEBANG_PASSTHROUGH[@]} -gt 0 ]] && CLAUDE_ARGS+=("${SHEBANG_PASSTHROUGH[@]}")
fi

# Resolve permission shortcuts (explicit flags take precedence)
if [[ -n "$PERMISSION_SHORTCUT" ]]; then
    if [[ "$EXPLICIT_PERMISSION_MODE" == true ]]; then
        print_warning "--$PERMISSION_SHORTCUT ignored: explicit --permission-mode or --dangerously-skip-permissions takes precedence"
    else
        case "$PERMISSION_SHORTCUT" in
            skip)   CLAUDE_ARGS+=("--dangerously-skip-permissions") ;;
            bypass) CLAUDE_ARGS+=("--permission-mode" "bypassPermissions") ;;
        esac
    fi
    PERMISSION_SHORTCUT=""  # Clear so shebang parsing doesn't re-resolve
fi

# Handle --version
if [[ "$SHOW_VERSION" == true ]]; then
    echo "ai-runner v$AI_RUNNER_VERSION"
    exit 0
fi

# Handle --help
if [[ "$SHOW_HELP" == true ]]; then
    cat << 'EOF'
ai - Run AI prompts as scripts and switch providers from the command line.

AI Runner wraps Claude Code with executable markdown and provider switching.
Write prompts in .md files with a shebang line, pipe content from stdin, or
launch interactive sessions -- all with a single command. Any flags not listed
here are passed straight through to the underlying tool (claude).

Usage:
  ai [OPTIONS] [file.md]       Execute a markdown prompt or start a session
  ai update                    Update AI Runner to the latest version

Modes:
  ai                           Interactive session (like running 'claude')
  ai prompt.md                 Execute markdown file as a prompt
  ./prompt.md                  Same, via #!/usr/bin/env ai shebang
  echo "Prompt" | ai           Execute piped text as a prompt
  curl <url> | ai              Execute remote markdown from stdin

Provider flags (pick one):
  --aws                        AWS Bedrock
  --vertex                     Google Vertex AI
  --apikey                     Anthropic API direct
  --azure                      Microsoft Azure
  --vercel                     Vercel AI Gateway
  --pro                        Claude Pro subscription
  --ollama, --ol               Local Ollama (free, Anthropic-API-compatible)
  --lmstudio, --lm             Local LM Studio (MLX support)

Model flags (pick one):
  --opus, --high               Highest-tier model
  --sonnet, --mid              Mid-tier model (default)
  --haiku, --low               Lowest-tier model
  --model <id>                 Specific model ID (e.g. claude-opus-4-6)

Tool flags:
  --tool <name>                Select AI tool (default: auto-detect)
  --cc                         Shorthand for --tool cc (Claude Code)

Permission shortcuts:
  --skip                       Shorthand for --dangerously-skip-permissions
  --bypass                     Shorthand for --permission-mode bypassPermissions

Agent teams (experimental):
  --team                       Enable agent teams (interactive mode only)
  --teammate-mode <mode>       Teammate display: in-process, tmux

Output and input:
  --output-format <fmt>        Output format: text, json, stream-json
  --live                       Stream text output in real-time (script mode)
  --stdin-position <pos>       Place piped input before or after file content:
                               'prepend' (default) or 'append'

Defaults:
  --set-default                Save current provider+model as persistent default
  --clear-default              Remove saved defaults

Other:
  --resume                     Resume the most recent conversation
  --version, -v                Show version
  --help, -h                   Show this help

Behavioral notes:

  Flag precedence (highest to lowest):
    1. CLI flags          ai --aws --opus file.md
    2. Shebang flags      #!/usr/bin/env -S ai --aws --opus
    3. Saved defaults     ai --aws --opus --set-default
    4. Auto-detection     Current Claude subscription

  CLI flags always override shebang flags, which override saved defaults.
  If no provider is specified anywhere, ai uses your current Claude
  subscription (same as running 'claude' directly).

  Stdin handling: When content is piped, it is prepended to the file content
  by default. Use --stdin-position append to place it after. If no file is
  given, piped content becomes the entire prompt.

  Exit codes: ai exits with the same code as the underlying tool. A non-zero
  exit means the tool reported an error.

  Passthrough: Any flag not recognized by ai (e.g. --verbose, --allowedTools)
  is forwarded to the underlying tool unchanged.

Examples:

  # Run a prompt file with the default provider
  ai task.md

  # Run with local Ollama (free, no API key needed)
  ai --ollama task.md

  # Run with AWS Bedrock using the strongest model
  ai --aws --opus task.md

  # Pipe a remote script to a local model
  curl https://example.com/prompt.md | ai --ollama

  # Start an interactive session with agent teams on AWS
  ai --aws --opus --team

  # Save AWS + Opus as your default, then just run 'ai'
  ai --aws --opus --set-default
  ai task.md   # uses saved AWS + Opus default

  # Make a prompt executable with a shebang
  cat > greet.md << 'PROMPT'
  #!/usr/bin/env ai --ollama --haiku
  Say hello and tell me a joke.
  PROMPT
  chmod +x greet.md
  ./greet.md

Backward compatibility:
  All claude-* commands (claude-run, claude-aws, etc.) still work.
  Shebangs using #!/usr/bin/env claude-run continue to work.

Full docs: https://airun.me
EOF
    exit 0
fi

# Config migration check (only for new ai command)
if needs_config_migration; then
    migrate_config_interactive
fi

# Load configuration
load_config_quiet

# Load saved defaults
load_defaults

# Handle --clear-default (standalone action)
if [[ "$CLEAR_DEFAULT" == true ]]; then
    clear_defaults
    exit 0
fi

# Apply saved defaults if no CLI flags
# Custom model is provider-specific, so only apply when provider also comes from defaults
CLI_PROVIDER_FLAG="$PROVIDER_FLAG"
CLI_MODEL_TIER="$MODEL_TIER"
CLI_CUSTOM_MODEL="$CUSTOM_MODEL"
CLI_TEAM_MODE="$TEAM_MODE"
[[ -z "$PROVIDER_FLAG" && -n "$AI_DEFAULT_PROVIDER" ]] && PROVIDER_FLAG="$AI_DEFAULT_PROVIDER"
[[ -z "$MODEL_TIER" && -z "$CUSTOM_MODEL" && -n "$AI_DEFAULT_MODEL_TIER" ]] && MODEL_TIER="$AI_DEFAULT_MODEL_TIER"
[[ -z "$CLI_PROVIDER_FLAG" && -z "$CUSTOM_MODEL" && -z "$MODEL_TIER" && -n "$AI_DEFAULT_CUSTOM_MODEL" ]] && CUSTOM_MODEL="$AI_DEFAULT_CUSTOM_MODEL"
[[ -z "$TEAM_MODE" && -n "$AI_DEFAULT_TEAM_MODE" ]] && TEAM_MODE="$AI_DEFAULT_TEAM_MODE"
if [[ -z "$TEAMMATE_MODE" && -n "$AI_DEFAULT_TEAMMATE_MODE" ]]; then
    TEAMMATE_MODE="$AI_DEFAULT_TEAMMATE_MODE"
    CLAUDE_ARGS+=("--teammate-mode" "$TEAMMATE_MODE")
fi

# Track whether we're running entirely from saved defaults (no CLI overrides)
USING_DEFAULTS=false
if [[ -z "$CLI_PROVIDER_FLAG" && -z "$CLI_MODEL_TIER" && -z "$CLI_CUSTOM_MODEL" ]] && [ -f "$DEFAULTS_FILE" ]; then
    USING_DEFAULTS=true
fi

# First-time setup (if needed and interactive)
if needs_first_time_setup && is_interactive; then
    run_first_time_setup || exit 1
    # Reload config after setup
    load_config_quiet
fi

#=============================================================================
# Auto-detection: Tool and Provider
#=============================================================================

# Auto-detect tool if not specified
if [[ -z "$TOOL_FLAG" ]]; then
    TOOL_FLAG=$(detect_default_tool)
    if [[ -z "$TOOL_FLAG" ]]; then
        print_no_tool_error
        exit 1
    fi
fi

# Load the selected tool
if ! load_tool "$TOOL_FLAG"; then
    exit 1
fi

# Check if tool is installed
if ! tool_is_installed; then
    tool_get_install_instructions
    exit 1
fi

# Auto-detect provider if not specified
if [[ -z "$PROVIDER_FLAG" ]]; then
    PROVIDER_FLAG=$(detect_default_provider)
    if [[ -z "$PROVIDER_FLAG" ]]; then
        print_no_provider_error
        exit 1
    fi
fi

# Load the selected provider
if ! load_provider "$PROVIDER_FLAG"; then
    exit 1
fi

# Validate provider configuration
_PROVIDER_FAILED=false
if ! provider_validate_config; then
    if [[ "$PROVIDER_FLAG" == "lmstudio" || "$PROVIDER_FLAG" == "ollama" ]]; then
        provider_get_validation_error >&2
        _PROVIDER_FAILED=true
    else
        provider_get_validation_error >&2
        exit 1
    fi
fi

if [[ "$_PROVIDER_FAILED" == false ]]; then
    # Check tool-provider compatibility
    if ! tool_supports_provider "$PROVIDER_FLAG"; then
        print_warning "$(tool_name) may not fully support $(provider_name)"
    fi

    # Set default model tier if not specified
    # Pro subscription: leave unset so Claude Code uses its own latest default
    # API/BYOK providers: default to "mid" (Sonnet) to manage costs
    if [[ -z "$MODEL_TIER" && -z "$CUSTOM_MODEL" ]]; then
        if [[ "$PROVIDER_FLAG" != "pro" ]]; then
            MODEL_TIER="mid"
        fi
    fi

    # Setup provider environment
    if ! provider_setup_env "$MODEL_TIER" "$CUSTOM_MODEL"; then
        if [[ "$PROVIDER_FLAG" == "lmstudio" || "$PROVIDER_FLAG" == "ollama" ]]; then
            _PROVIDER_FAILED=true
        else
            exit 1
        fi
    fi
fi

#=============================================================================
# Fallback: local provider unavailable â€” auto-detect default provider
#=============================================================================
if [[ "$_PROVIDER_FAILED" == true ]]; then
    echo "" >&2
    # Reset model selections (were for local provider)
    MODEL_TIER=""
    CUSTOM_MODEL=""

    # Auto-detect fallback (clear DEFAULT_PROVIDER to avoid re-selecting failed provider)
    _FAILED_PROVIDER="$PROVIDER_FLAG"
    _saved_default_provider="$DEFAULT_PROVIDER"
    DEFAULT_PROVIDER=""
    PROVIDER_FLAG=$(detect_default_provider)
    DEFAULT_PROVIDER="$_saved_default_provider"

    if [[ -z "$PROVIDER_FLAG" || "$PROVIDER_FLAG" == "$_FAILED_PROVIDER" ]]; then
        print_error "No fallback provider available. Run ai-status to check your setup."
        exit 1
    fi

    load_provider "$PROVIDER_FLAG" || exit 1
    provider_validate_config || { provider_get_validation_error >&2; exit 1; }

    if [[ -z "$MODEL_TIER" && -z "$CUSTOM_MODEL" && "$PROVIDER_FLAG" != "pro" ]]; then
        MODEL_TIER="mid"
    fi

    provider_setup_env "$MODEL_TIER" "$CUSTOM_MODEL" || exit 1
    print_warning "Falling back to $(provider_name)"
fi

#=============================================================================
# Setup Environment
#=============================================================================

# Save as default if requested
if [[ "$SET_DEFAULT" == true ]]; then
    save_defaults "$PROVIDER_FLAG" "$MODEL_TIER" "$CUSTOM_MODEL" "$TEAM_MODE" "$TEAMMATE_MODE"
fi

# Setup tool environment
tool_setup_env

# Setup agent teams if requested
if [[ -n "$TEAM_MODE" ]]; then
    export CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1
fi

# Generate session ID
AI_SESSION_ID="$(tool_flag)-$(provider_flag)-$$-$(date +%s)"
export AI_SESSION_ID

# Write session information
write_session_info \
    "$(provider_name)" \
    "BYOK" \
    "${ANTHROPIC_MODEL:-(system default)}" \
    "$ANTHROPIC_SMALL_FAST_MODEL" \
    "$(provider_get_region 2>/dev/null || echo '')" \
    "$(provider_get_project 2>/dev/null || echo '')" \
    "$(provider_get_auth_method)" \
    "$(tool_flag)" \
    "$TEAM_MODE"

# Cleanup on exit
cleanup_on_exit() {
    cleanup_session_info
    provider_cleanup_env
}
trap cleanup_on_exit EXIT

# Add --verbose if stream-json output format requires it
if [[ "$NEEDS_VERBOSE" == true ]]; then
    CLAUDE_ARGS=("--verbose" "${CLAUDE_ARGS[@]}")
fi

# Handle --live mode
if [[ "$LIVE_OUTPUT" == true ]]; then
    if ! command -v jq &>/dev/null; then
        print_error "--live requires jq. Install with: brew install jq"
        exit 1
    fi
    CLAUDE_ARGS+=("--output-format" "stream-json" "--verbose")
    export AI_LIVE_OUTPUT=true
fi

# Skip --team in non-interactive mode (shebang/piped)
if [[ -n "$TEAM_MODE" ]] && [[ -n "$MD_FILE" || -n "$STDIN_CONTENT" ]]; then
    # Only warn if --team was explicitly passed on CLI (not from saved defaults)
    [[ -n "$CLI_TEAM_MODE" ]] && print_warning "Agent teams (--team) requires interactive mode. Ignoring flag."
    TEAM_MODE=""
    unset CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS
fi

#=============================================================================
# MODE 1: SHEBANG/FILE EXECUTION (non-interactive)
#=============================================================================
if [[ -n "$MD_FILE" ]]; then
    # Read file content, strip shebang if present
    if [[ "$(head -1 "$MD_FILE")" == "#!"* ]]; then
        CONTENT=$(tail -n +2 "$MD_FILE")
    else
        CONTENT=$(cat "$MD_FILE")
    fi

    # Integrate stdin content if available
    if [[ -n "$STDIN_CONTENT" ]]; then
        if [[ "$STDIN_POSITION" == "prepend" ]]; then
            CONTENT="The following input was provided via stdin:
---
$STDIN_CONTENT
---

$CONTENT"
        else
            CONTENT="$CONTENT

---
The following input was provided via stdin:
---
$STDIN_CONTENT"
        fi
    fi

    # Show status when interactive or when --live with stderr on a terminal
    if is_interactive || [[ "$LIVE_OUTPUT" == true && -t 2 ]]; then
        print_status "Using: $(tool_name) + $(provider_name)"
        print_status "Model: ${ANTHROPIC_MODEL:-(system default)}"
    fi

    # Execute with prompt mode
    tool_execute_prompt "$CONTENT" "${CLAUDE_ARGS[@]}"
    exit $?
fi

#=============================================================================
# MODE 2: PIPED SCRIPT EXECUTION (stdin without file)
#=============================================================================
if [[ -n "$STDIN_CONTENT" ]]; then
    # Strip shebang line from piped content if present (flags already parsed early)
    FIRST_LINE="${STDIN_CONTENT%%$'\n'*}"
    [[ "$FIRST_LINE" == "#!"* ]] && CONTENT="${STDIN_CONTENT#*$'\n'}" || CONTENT="$STDIN_CONTENT"

    # Show status when interactive or when --live with stderr on a terminal
    if is_interactive || [[ "$LIVE_OUTPUT" == true && -t 2 ]]; then
        print_status "Using: $(tool_name) + $(provider_name)"
        print_status "Model: ${ANTHROPIC_MODEL:-(system default)}"
    fi

    # Execute with prompt mode
    tool_execute_prompt "$CONTENT" "${CLAUDE_ARGS[@]}"
    exit $?
fi

#=============================================================================
# MODE 3: INTERACTIVE (launch tool with provider configured)
#=============================================================================

# Show banner
display_banner

# Check for updates (non-blocking, cache-only)
source "$LIB_DIR/update-checker.sh"
if check_for_update; then print_update_notice; fi

_activation_msg="$(tool_name) + $(provider_name) mode activated"
[[ "$USING_DEFAULTS" == true ]] && _activation_msg+=" (default)"
print_success "$_activation_msg"
print_status "- Provider: $(provider_name)"
print_status "- Auth: $(provider_get_auth_method)"
print_status "- Model: ${ANTHROPIC_MODEL:-(system default)}"
if [[ -n "$ANTHROPIC_SMALL_FAST_MODEL" ]]; then
    print_status "- Small/Fast Model: $ANTHROPIC_SMALL_FAST_MODEL"
fi
if [[ -n "$TEAM_MODE" ]]; then
    print_status "- Agent Teams: enabled"
fi
# Provider-specific extra info (e.g., system capabilities for Ollama)
provider_print_extra_info

# Show auth conflict note for API key mode (if user is also logged into Claude Pro)
if [[ "$PROVIDER_FLAG" == "apikey" ]] && [[ -n "$ANTHROPIC_API_KEY" ]]; then
    echo ""
    print_warning "Note: If you see an 'Auth conflict' warning below, this is expected."
    print_status "Your API key will be used for billing. The warning is informational only."
    print_status "To permanently switch to API-only mode, run: claude /logout"
    echo ""
fi

print_status "Launching $(tool_name)..."

# Launch tool in interactive mode
tool_execute_interactive "${CLAUDE_ARGS[@]}"
